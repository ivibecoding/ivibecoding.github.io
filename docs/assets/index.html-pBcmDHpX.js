import{_ as e,c as a,b as l,o as s}from"./app-3lQNyhbE.js";const d={};function h(o,t){return s(),a("div",null,[...t[0]||(t[0]=[l('<h2 id="什么是hash" tabindex="-1"><a class="header-anchor" href="#什么是hash"><span>什么是Hash？</span></a></h2><blockquote><p>Hash 翻译做“散列”，也可直译为“哈希”，就是把任意长度的值输入，通过hash()函数输出固定长度的消息摘要。 Hash函数也有很多种，包括：直接取余法，乘法取整法，平方取中法，暂时先了解有这些方法即可。它其实就是一个算法，最简单的算法就是加减乘除，比方，我设计个数字算法，输入+7=输出，比如我输入1，输出为8；输入2，输出为9。</p></blockquote><h3 id="hash特性" tabindex="-1"><a class="header-anchor" href="#hash特性"><span>Hash特性</span></a></h3><ul><li>不可逆： 在具备编码功能的同时，哈希算法也作为一种加密算法存在。即，你无法通过分析哈希值计算出源文件的样子，换句话说：你不可能通过观察香肠的纹理推测出猪原来的样子。</li><li>计算极快： 20G高清电影和一个5K文本文件复杂度相同，计算量都极小，可以在0.1秒内得出结果。也就是说，不管猪有多肥，骨头多硬，做成香肠都只要眨眨眼的时间。</li></ul><h2 id="hashcode的作用" tabindex="-1"><a class="header-anchor" href="#hashcode的作用"><span>HashCode的作用？</span></a></h2><ul><li>HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的</li><li>如果两个对象equals相等，那么这两个对象的HashCode一定也相同</li><li>如果对象的equals方法被重写，那么对象的HashCode方法也尽量重写</li><li>如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</li></ul><h3 id="hashcode和equals" tabindex="-1"><a class="header-anchor" href="#hashcode和equals"><span>Hashcode和Equals</span></a></h3><p>例如内存中有这样的位置 0 1 2 3 4 5 6 7 而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用Hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。 但如果用Hashcode那就会使效率提高很多。 我们这个类中有个字段叫ID,那么我们就定义我们的Hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是 13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。</p><p>但是如果两个类有相同的Hashcode怎么办呢（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。 也就是说，我们先通过 Hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 Equals 来在这个桶里找到我们要的类。 那么。重写了equals()，为什么还要重写hashCode()呢？ 想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写Hashcode()来找到桶，光重写Equals()有什么用啊</p><h2 id="hashset是什么" tabindex="-1"><a class="header-anchor" href="#hashset是什么"><span>HashSet是什么?</span></a></h2><p>所谓的HashSet，指的就是 System.Collections.Generic 命名空间下的 <code>HashSet&lt;T&gt;</code> 类，它是一个高性能，无序的集合，因此HashSet它并不能做排序操作，也不能包含任何重复的元素，Hashset 也不能像数组那样使用索引，所以在 HashSet 上你无法使用 for 循环，只能使用 foreach 进行迭代，HashSet 通常用在处理元素的唯一性上有着超高的性能。</p><p>HashSet 只能包含唯一的元素，它的内部结构也为此做了专门的优化，值得注意的是，HashSet 也可以存放单个的 null 值，可以得出这么一个结论：如何你想拥有一个具有唯一值的集合，那么 HashSet 就是你最好的选择，何况它还具有超高的检索性能。</p><p><code>HashSet&lt;T&gt;</code> 类 主要被设计用来存储集合，做高性能集运算，例如两个集合求交集、并集、差集等。从名称可以看出，它是基于Hash的，可以简单理解为没有Value 的 Dictionary。</p><p>优势在于集合运算快，作为一种存放在内存的数据，可以很快的进行设置和取值的操作。</p><h3 id="hashset-特性" tabindex="-1"><a class="header-anchor" href="#hashset-特性"><span>HashSet 特性</span></a></h3><ul><li><code>HashSet&lt;T&gt;</code> 的容量指的是可以容纳的元素总数，增减元素时，容量会自动增加，但不会自动减少。</li><li><code>HashSet&lt;T&gt;</code> 不自带排序方法，如果需要排序的可以参考使用 List 集合配合 Sort 方法。</li><li><code>HashSet&lt;T&gt;</code> 元素是唯一的，不可重复，同时区分大小写。</li><li><code>HashSet&lt;T&gt;</code> 不能使用下标来访问元素。</li></ul><p>#638 HashSet使用案例</p><h3 id="hashset-t-的优势和与-list-t-的比较" tabindex="-1"><a class="header-anchor" href="#hashset-t-的优势和与-list-t-的比较"><span><code>HashSet&lt;T&gt;</code> 的优势和与 <code>List&lt;T&gt;</code> 的比较</span></a></h3><p><code>HashSet&lt;T&gt;</code> 最大的优势是检索的性能，简单的说它的 Contains 方法的性能在大数据量时比 <code>List&lt;T&gt;</code> 好得多。</p><p>在内部算法实现上，<code>HashSet&lt;T&gt;</code> 的 Contains 方法复杂度是 O(1)，<code>List&lt;T&gt;</code> 的 Contains 方法复杂度是 O(n)，后者数据量越大速度越慢，而 <code>HashSet&lt;T&gt;</code>不受数据量的影响。</p><blockquote><p>这里的方法复杂度就是 时间复杂度 和 空间复杂度 的综合评定。 时间复杂度和空间复杂度详解： https://blog.csdn.net/qq_47897078/article/details/124646714 https://blog.csdn.net/qq_49613557/article/details/115301174</p></blockquote><p>所以在集合的目的是为了检索的情况下，我们应该使用 <code>HashSet&lt;T&gt;</code> 代替 <code>List&lt;T&gt;</code> 。比如一个存储关键字的集合，运行的时候通过其 Contains 方法检查输入字符串是否关键字。</p><p>如果你必须建立新的设定，或者如果应用程序只需要存取提供的任务，那么使用任何的IEnumerable集合都已经足够了。但是，如果应用程序需要存取其他值，或则不建议不需要建立新的集合，这时可使用HashSet</p><h3 id="hashset-t-类的方法和属性" tabindex="-1"><a class="header-anchor" href="#hashset-t-类的方法和属性"><span><code>HashSet&lt;T&gt;</code> 类的方法和属性</span></a></h3><ul><li><code>HashSet&lt;T&gt;</code> 类的一些常用的 属性：</li></ul><table><thead><tr><th style="text-align:left;">属性</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">Count</td><td style="text-align:center;">获取集合中现有元素的总数</td></tr></tbody></table><ul><li><code>HashSet&lt;T&gt;</code> 类的一些常用的 方法：</li></ul><table><thead><tr><th style="text-align:left;">方法</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">bool Add (T item);</td><td style="text-align:center;">添加指定元素，返回bool值指示是否执行成功</td></tr><tr><td style="text-align:left;">bool Remove (T item);</td><td style="text-align:center;">移除指定元素，返回bool值表示是否执行成功</td></tr><tr><td style="text-align:left;">void Clear ();</td><td style="text-align:center;">移除所有元素</td></tr><tr><td style="text-align:left;">bool Contains (T item);</td><td style="text-align:center;">判断是否包含指定元素</td></tr><tr><td style="text-align:left;">void CopyTo (T[] array);</td><td style="text-align:center;">复制元素到数组中</td></tr><tr><td style="text-align:left;">void ExceptWith (IEnumerable《T》 other);</td><td style="text-align:center;">移除当前集合中指定子集的元素</td></tr><tr><td style="text-align:left;">void IntersectWith (IEnumerable《T》 other);</td><td style="text-align:center;">修改当前集合元素为当前集合与指定集合的交集</td></tr><tr><td style="text-align:left;">void UnionWith (IEnumerable other);</td><td style="text-align:center;">修改当前集合元素为当前集合与指定集合的并集</td></tr><tr><td style="text-align:left;">bool IsProperSubsetOf (IEnumerable other);</td><td style="text-align:center;">判断当前集合是否为指定集合的真子集</td></tr><tr><td style="text-align:left;">bool IsProperSupersetOf (IEnumerable other);</td><td style="text-align:center;">判断当前集合是否为指定集合的真超集</td></tr><tr><td style="text-align:left;">bool IsSubsetOf (IEnumerable other);</td><td style="text-align:center;">判断当前集合是否为指定集合的子集</td></tr><tr><td style="text-align:left;">bool IsSupersetOf (IEnumerable other);</td><td style="text-align:center;">判断当前集合是否为指定集合的超集</td></tr><tr><td style="text-align:left;">bool Overlaps (IEnumerable other);</td><td style="text-align:center;">判断当前集合是否与指定集合至少有一个公共元素</td></tr><tr><td style="text-align:left;">bool SetEquals (IEnumerable other);</td><td style="text-align:center;">判断当前集合是否与指定集合包含相同的元素</td></tr><tr><td style="text-align:left;">bool TryGetValue (T equalValue, out T actualValue);</td><td style="text-align:center;">搜索给定值，并返回所找到的相等值</td></tr><tr><td style="text-align:left;">void TrimExcess ();</td><td style="text-align:center;">将当前集合的容量设置为它包含的实际元素数</td></tr></tbody></table><h2 id="hashtable简述" tabindex="-1"><a class="header-anchor" href="#hashtable简述"><span>HashTable简述</span></a></h2><blockquote><p>在.NET Framework中，Hashtable是System.Collections命名空间提供的一个容器，用于处理和表现类似keyvalue的键值对，其中key通常可用来快速查找，同时key是区分大小写；value用于存储对应于key的值。Hashtable中keyvalue键值对均为object类型，所以Hashtable可以支持任何类型的keyvalue键值对.</p></blockquote><p>#639 HashTable使用案例</p><h2 id="hashset源码比较" tabindex="-1"><a class="header-anchor" href="#hashset源码比较"><span>HashSet源码比较</span></a></h2><blockquote><p>HashSet的内部实现跟Dictionary几乎是一模一样的，差别仅在于HashSet没有key，只有value，所以存储的时候是用value的HashCode值进行判断。</p></blockquote><p>HashSet源码：https://source.dot.net/#System.Private.CoreLib/HashSet.cs Dictionary源码：https://source.dot.net/#System.Private.CoreLib/Dictionary.cs</p>',34)])])}const n=e(d,[["render",h]]),i=JSON.parse('{"path":"/docs/uuuq1uz3/","title":"Hash","lang":"zh-CN","frontmatter":{"title":"Hash","createTime":"2026/01/23 14:34:22","permalink":"/docs/uuuq1uz3/"},"readingTime":{"minutes":7,"words":2100},"git":{},"filePathRelative":"docs/CSharp/Hash/Hash.md","headers":[]}');export{n as comp,i as data};
