import{_ as i,c as a,a as t,o as e}from"./app-BZ1Wmvro.js";const n={};function r(l,s){return e(),a("div",null,[...s[0]||(s[0]=[t(`<h2 id="array-vs-list" tabindex="-1"><a class="header-anchor" href="#array-vs-list"><span>array vs list</span></a></h2><p>Currently List makes an &quot;additional bounds check&quot; to the one array does. In other words when accessing List indexer or list iterator it must make sure the index given is less than list size. Plus, iterator checks &quot;version&quot;. That is relatively big overhead that makes accessing List much slower than array.</p><h2 id="string-vs-stringbuilder-vs-span" tabindex="-1"><a class="header-anchor" href="#string-vs-stringbuilder-vs-span"><span>string vs StringBuilder vs span</span></a></h2><h2 id="struct-vs-class" tabindex="-1"><a class="header-anchor" href="#struct-vs-class"><span>struct vs class</span></a></h2><h2 id="double-vs-float" tabindex="-1"><a class="header-anchor" href="#double-vs-float"><span>double vs float</span></a></h2><h2 id="if-vs-switch" tabindex="-1"><a class="header-anchor" href="#if-vs-switch"><span>if vs switch</span></a></h2><p>Notes, switch slower. It is tempting to think that a switch is always faster than an equivalent if-statement. However, this is not true. And: A situation where the switch is slower is when the actual runtime of the program has a very skewed distribution of inputs.</p><p>Benchmark So: If the input is almost always a specific value, then using an if-statement to test for that value may be faster.</p><h2 id="for-vs-foreach" tabindex="-1"><a class="header-anchor" href="#for-vs-foreach"><span>for vs foreach</span></a></h2><p>对Array来说，for和foreach效率一样，推荐使用foreach 对List来说，for的效率高于foreach，推荐使用for</p><h2 id="dictionary-vs-linq" tabindex="-1"><a class="header-anchor" href="#dictionary-vs-linq"><span>dictionary vs linq</span></a></h2><p>linq的ToArray和ToList效率一样，主要区别在于后期使用</p><h2 id="sort-sortedlist-vs-sorteddictionary" tabindex="-1"><a class="header-anchor" href="#sort-sortedlist-vs-sorteddictionary"><span>sort SortedList vs SortedDictionary</span></a></h2><h2 id="buffer-blockcopy-vs-array-copy" tabindex="-1"><a class="header-anchor" href="#buffer-blockcopy-vs-array-copy"><span>Buffer.BlockCopy vs Array.Copy</span></a></h2><h1 id="c-、dotnet中常见的性能优化点" tabindex="-1"><a class="header-anchor" href="#c-、dotnet中常见的性能优化点"><span>C#、DotNet中常见的性能优化点</span></a></h1><h2 id="benchmark和源码查询" tabindex="-1"><a class="header-anchor" href="#benchmark和源码查询"><span>Benchmark和源码查询</span></a></h2><p><em>Know What Things Cost.</em> （了解事情的成本）</p><p>编写代码时候要保持好奇心，了解常见底层方法和类的实现原理。既可以<a href="https://www.stevejgordon.co.uk/become-a-better-developer-by-reading-source-code" target="_blank" rel="noopener noreferrer">学习他人编程的技巧</a>，也可以更好的决定如何实现功能。 比如：下面是<code>List&lt;T&gt;.Insert</code>的代码。可以看出insert并不是一个很高效的实现，在实现功能的时候应该尽量避免。</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-csharp"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">       public</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Insert</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> index</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> T</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> item</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">           //如果超出Capacity，List内部的_items Array会Resize</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">           if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">_size</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ==</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> _items</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Length</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> EnsureCapacity</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">_size</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">           if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">index</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &lt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> _size</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">               //会把插入索引后的所有值向前Copy一遍</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">               Array</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Copy</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">_items</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> index</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> _items</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> index</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> _size</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> index</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">           }</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">           _items</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">index</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> item</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">           _size</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">            </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">       }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Benchmark作为测试性能的工具，也可以让我们对不同实现方法在不同情况下进行比较，更好的优化代码。</p><blockquote><p><strong style="color:green;">提示</strong></p><ul><li>不要<strong>assume</strong>，而是<strong>measure</strong>。熟知所有底层基础操作的成本。(for foreach; list array; dictionnary find; switch if;)</li><li>并不是所有代码都需要Benchmark或者优化，主要是<strong>Hot Path</strong>关键路径中的方法。</li><li>Benchmark尽量模拟项目中使用案例。</li><li>采用<code>[Params(length1,length2)]</code>可以同时模拟不同数据量的情况，注意<a href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/210801?fr=aladdin" target="_blank" rel="noopener noreferrer">算法复杂度</a>（时间和空间）O(f(N))</li></ul></blockquote><h2 id="allocation减少没必要的内存分配" tabindex="-1"><a class="header-anchor" href="#allocation减少没必要的内存分配"><span>Allocation减少没必要的内存分配</span></a></h2><p><em>The rule of thumb is to have objects de-allocated as fast as possible or not at all.</em> （经验法则是尽可能快地回收对象，或者根本不回收）</p><p>在 .NET 应用程序中，内存和性能非常相关。内存管理不当会在许多方面影响性能。一种效应称为 GC 压力或内存压力。</p><p>GC 压力（垃圾回收器压力）是 GC 跟不上内存处理时的压力。当 GC 受到压力时，它将花费更多时间进行垃圾收集，并且这些收集将更频繁地出现。当程序花费更多时间进行垃圾收集时，它执行代码的时间会更少，从而直接损害性能。</p><h3 id="常见的优化点" tabindex="-1"><a class="header-anchor" href="#常见的优化点"><span>常见的优化点：</span></a></h3><ul><li>✔<strong>考虑</strong> 使用ArraySegment、ArrayPool或者Span对数组分段处理</li><li>✔<strong>考虑</strong> 使用SpanView对文件进行读写</li><li><strong>推荐</strong> List、Collection、Dictionary等已知长度时候，新建应该设置初始Capacity</li><li>✔<strong>考虑</strong> 当string合并大于10个时候，应该是用<code>StringBuilder</code>，string复杂操作时候使用<code>Span</code></li><li><a href="https://devblogs.microsoft.com/pfxteam/know-thine-implicit-allocations/" target="_blank" rel="noopener noreferrer">了解更多</a></li></ul><h2 id="memoryleak内存泄漏" tabindex="-1"><a class="header-anchor" href="#memoryleak内存泄漏"><span>MemoryLeak内存泄漏</span></a></h2><p>内存泄漏有两个相关的核心原因。第一个核心原因是，当对象仍然被引用，但实际上未使用。由于它们被引用，GC 不会收集它们，它们将永久保留，占用内存。例如，当您注册到事件但永远不会取消注册时，可能会发生这种情况。让我们称之为托管内存泄漏。</p><p>第二个原因是，当您以某种方式分配非托管内存（不进行垃圾回收）并且不释放它时。这并不难做到。.NET 本身有许多类分配非托管内存。几乎任何涉及流、图形、文件系统或网络调用的东西都这样做。通常，这些类实现<code>Dispose</code>方法，该方法释放内存。您可以使用特殊的 .NET 类（如<code>Marshal</code>）或使用 <code>PInvoke</code> 轻松分配非托管内存。</p><h3 id="常见原因" tabindex="-1"><a class="header-anchor" href="#常见原因"><span>常见原因：</span></a></h3><ul><li>事件没有注销<strong>监听</strong></li><li>❌<strong>匿名函数</strong>，会增加内部调用的变量所在Class的引用，作为Timer事件Handle时候或者在Task中长期运行时会出现内存泄漏。</li><li>Static<strong>静态变量</strong>或者<strong>全局单例</strong>的变量中引用的类</li><li><strong>Dispose</strong>没有调用，或者Dispose中没有释放所有事件监听和其他继承Dispose的变量（如Bitmap）</li><li><a href="https://michaelscodingspot.com/ways-to-cause-memory-leaks-in-dotnet/" target="_blank" rel="noopener noreferrer">了解更多</a></li></ul><h2 id="c-常见性能优化项" tabindex="-1"><a class="header-anchor" href="#c-常见性能优化项"><span>C#常见性能优化项</span></a></h2><ul><li><strong>推荐</strong> 使用<strong>const</strong></li><li>Array vs Collection vs Dictionary选择时，查询使用Dic，已知长度使用array等。</li><li>❌<strong>避免</strong> <strong>Throwing Exceptions</strong> 抛出和捕捉异常是非常昂贵的操作，应该在提前预知可能性的时候使用if或者类似TryParse的方法去避免TryCatch逻辑判断。</li><li>❌<strong>避免</strong> <strong>Reflection</strong> 反射是很耗时的操作，尽量避免。尽量使用基类或者接口。</li><li>❌<strong>避免</strong> The <strong>dynamic</strong> type is particularly expensive. Try avoiding it entirely in hot paths.</li><li><strong>禁止</strong> <strong>Boxing</strong>避免装箱拆箱的操作，比如<code>HashTable</code>，<code>ArrayList</code>，或者方法接口使用<strong>object</strong></li><li>✔<strong>考虑</strong> <strong>Caching</strong>数据，频繁访问数据或者操作比较费时的数据结果，应该考虑使用缓存或者文件暂存。Cache也不能太多，增加内存压力。Cache也有可能会引起内存泄漏，设计时候请考虑。Cache验证失效的机制也不能比信息获取消耗更大，适得其反。</li></ul><h2 id="hot-path关键访问路径" tabindex="-1"><a class="header-anchor" href="#hot-path关键访问路径"><span>Hot Path关键访问路径</span></a></h2><p>Hot Path是指程序中经常被调用的方法，关键功能的算法，比如以下几类：</p><ul><li><strong>数据库</strong>读写，和实体模型之间<strong>映射</strong></li><li><strong>文件</strong>读写和<strong>序列化</strong></li><li>网络或者硬件<strong>通讯</strong></li><li><strong>海量</strong>数据（&gt;100）计算，查询，排序等</li><li>框架<strong>底层</strong>机制</li><li><strong>公用</strong>控件和帮助类</li></ul><p>Hot Path中的方法实现应该尽量设计周全，进行必要的<strong>Benchmark</strong>和<strong>Memory Diagnostic</strong>（内存诊断)。 在关键的地方，除了上面提到的Allocation(内存分配)，Memory Leak（内存泄漏）等，下面这些看起来比较<strong>极端</strong>的操作也是必须考虑的。</p><ul><li>✔<strong>考虑</strong>设计更好的<strong>查询</strong>方法，Dictionary或者Binary Search或者Cache查询的Index等。</li><li>❌<strong>避免</strong> 使用LINQ（ToArray，ToList，Min，Where等）OrderBy和Distinct考虑使用使用SortedList，HashSet等</li><li>✔<strong>考虑</strong> 相比List优先使用<strong>Array</strong>，相比foreach优先使用<strong>for</strong></li><li>❌<strong>避免</strong> 循环里面判断，先<strong>判断</strong>再循环。循环中执行代码最简化，缓存<strong>Cache</strong>临时变量，而不是循环调用方法获取。</li><li>❌<strong>避免</strong> String的<code>Split</code>、<code>SubString</code>等，使用<strong>Span</strong>的Split和Slide</li><li>❌<strong>避免</strong> 方法参数使用param时候，应该实现常用个数（比如单参数和双参数）的情况，避免多余List的Allocation</li><li>✔<strong>考虑</strong> 参数或者变量使用具体的类，如<code>double[]</code>、<code>List&lt;double&gt;</code>，而不是接口Interface。 接口调用会有<a href="https://github.com/dotnet/runtime/issues/7291" target="_blank" rel="noopener noreferrer">多余开销</a>,考虑实现常用具类的方法，或者增加<code>is</code>的cast。如：<code>if(interface is double[] array){}</code></li><li>✔<strong>考虑</strong> 个别情况使用<a href="https://adamsitnik.com/Value-Types-vs-Reference-Types/" target="_blank" rel="noopener noreferrer">Struct或者ValueTuple</a>相比于Class，比如，当数据结构小于等于16bytes（4个int）大小的时候，struct更加高效。参考wpf中的Color和Point。</li><li>✔<strong>考虑</strong> 复杂Struct结构体尽量定义为readonly，传参时候使用ref，或者定义为readonly ref，减少没必要的内存复制。</li><li>✔<strong>考虑</strong> 极端情况下，256bytes大小内的数组考虑使用stackalloc。<code>Span&lt;byte&gt; bytes = stackalloc byte[2];</code></li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li>⭐官方dotnet https://docs.microsoft.com/en-us/dotnet/framework/performance/performance-tips</li><li>⭐官方readonly struct https://docs.microsoft.com/en-us/dotnet/csharp/write-safe-efficient-code</li><li>⭐ https://www.stevejgordon.co.uk/writing-high-performance-csharp-and-dotnet-code</li><li>视频教程Writing Allocation Free Code in C# https://www.bilibili.com/video/av39019704/</li><li>https://michaelscodingspot.com/performance-problems-in-csharp-dotnet/</li><li>https://michaelscodingspot.com/avoid-gc-pressure/</li><li>https://www.dotnetperls.com/optimization</li><li>https://github.com/adamsitnik/awesome-dot-net-performance</li></ul>`,41)])])}const h=i(n,[["render",r]]),p=JSON.parse('{"path":"/docs/8qk07vob/","title":"原生类型和操作性能对比","lang":"zh-CN","frontmatter":{"title":"原生类型和操作性能对比","createTime":"2026/01/23 14:32:51","permalink":"/docs/8qk07vob/"},"readingTime":{"minutes":6.7,"words":2009},"git":{"createdTime":1769153516000,"updatedTime":1769153516000,"contributors":[{"name":"Z小染","username":"","email":"ryning@sina.com","commits":1,"avatar":"https://gravatar.com/avatar/7097c8ff6482a07ed82070960a9644dc6c0e6b6954b8ae4d6b5bdba65812d1ad?d=retro"}]},"filePathRelative":"docs/CSharp/PerformanceGuidelines.md","headers":[]}');export{h as comp,p as data};
