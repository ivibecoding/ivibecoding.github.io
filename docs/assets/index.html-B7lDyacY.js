import{_ as s,c as n,a,o as i}from"./app-BuzjU66J.js";const l="/assets/4-4YfdrQVS.png",t={};function d(c,e){return i(),n("div",null,[...e[0]||(e[0]=[a(`<h1 id="深入事件循环-in-the-loop" tabindex="-1"><a class="header-anchor" href="#深入事件循环-in-the-loop"><span>深入事件循环（In the Loop）</span></a></h1><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">document.body.appendChild(el)</span>
<span class="line">el.style.display = &#39;none</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码你会想到什么，第一没有分号，这让人很难受，第二这貌似是一个让元素进行隐藏的一个功能但是这样隐藏这一个问题就是会元素会先加载出来，在某种情况下会有一闪变成隐藏的可能一般情况下为了解决这个问题我们通常初始化都会是隐藏状态。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">el.style.display = &#39;none&#39;</span>
<span class="line">document.body.appendChild(el)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>网页中存在一个主线程，称之为主线程主要是因为这里发生大量的事情，可以发生 js，渲染和 dom 的存在。这就意味着网页上大部分的代码执行都是有一定的执行顺序。我们不会同时运行多段代码同时运行同一处 dom。但是如果主线程需要很长时间，那用户就需要等待很久。因为会组织加载和交互。</p><p>形象的比喻，人就是一个多线程的，因为我们同时可以说话，也可以抬脚，不存在阻塞。但是人在睡觉的时候就是一个单线程的不可以进行行为，当睡觉的时候不能说话也不能思考。所以我们也不希望自己能写出这种单线程的程序来。因此我们有主线程，我们还需要其他线程来请求网络。但是，一旦这些主线程有了需要页面响应的操作。他们需要通知主线程，这里就需要事件循环来协调所有这些活动。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">setTimeout(callback,ms)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>运行 setTimeout 指的是等待指定时间，触发回掉函数，完成，但是这并不正确，因为 setTimeout 方法和回调函数运行在同一个线程上.js 在主线程上运行，所以当我们等待 5000 毫秒时，我们是在主线程上等待，阻止了主线程其他活动。换句话说如果是主线程上，我们将其改成同时运行这两个步骤，就是同时执行这两个步骤，就会遇到新的问题。也就是在主线程以外出发这个线程。这样是行不通的，因为最终会有大量并行运行的 js，编辑相同的 dom。最终的解决方案是，创建一个任务加入到任务队列。以便在某个时刻回到主线程执行，现在我们在 js 所在的线程上调用 js，这样就行的通了。</p><p>当我们像任务队列加入任务时，事件环会绕道而行到这里，这是执行任务的地方。浏览器对事件循环，说，我有一个任务交给你。事件循环会把他添加到代办时间列表，如果将 setTimeout 来将两个回调函数加入到任务队列中。根据之前的编写规则，1000 好秒后同步出发 callback1，callback2.，这其实就是任务队列。</p><p>如果渲染 css 样式的时候，会更加复杂。如图所示。 <img src="`+l+`" alt=""></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">// 如果直接执行btn之后下面在执行的点击事件，或者其余事件都无法继续进行。</span>
<span class="line">function btn(){</span>
<span class="line">	while(true){</span>
<span class="line">  	alert(2)</span>
<span class="line">   }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>刚开始写的代码找到元素执行样式 none 总担心会闪现，其实是不会的。因为脚本作为任务的一部分，必须执行结束，浏览器才会渲染。事件循环可以确保你的任务在下一次渲染之前完成。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function loop(){</span>
<span class="line">	setTimeout(loop,0);</span>
<span class="line">}</span>
<span class="line">loop();</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们将一个任务加入队列，需要执行任务，我们再加入另一个任务，一直这样，往复循环。每次只能处理一个任务。当他处理一个任务时，它必须绕事件一圈，来接受下一个任务。</p><p>案例：通过一段代码来移动盒子，每次我将盒子向前移动一个像素。然后使用 requestAnimationFrame(RAF)来创建一个循环</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function callback(){</span>
<span class="line">	moveBoxForwardOnePixel();</span>
<span class="line">  requestAnimationFrame(callback); // setTimeout(callback,0)</span>
<span class="line">}</span>
<span class="line">callback();</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码如果将 requestAnimationFrame 更改为 setTimeout 我们会看出高于前者 3.5 倍速。这是为什么。两者的刷新时间不同，前者的刷新时间和浏览器更新时间更贴切。这意味着回调被平凡的调用并不是一件好事。 所以渲染由浏览器来决定何时渲染，会更加高效，有时候会走好几个任务才会进行渲染界面。只有值得更新才会被渲染，如果没有改动则不会被渲染展示。如果浏览器运行在后台，不会被渲染，因为没有任何意义。大多数情况下，浏览器会固定更新，每秒 60 次的，有的屏幕快些，有的则慢些。 60 赫兹其实是很常见的，如果 1 秒内将页面样式改变 1000 次，浏览器也不会运行渲染 1000 次。他会和显示器同步，仅渲染显示器能够达到的帧数。通常是美妙 60 次，否则也是浪费。渲染用户也看不到。</p><p>如果制作动画，我们使用 setTimeout 的时候如果设置成 0 秒更新，其实有跟多针是没有被渲染出来的。一般的解决办法是使用</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">setTimeout(animFrame,1000/60)</span>
<span class="line">// 因为每秒执行60次</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，如果我们使用 setTimeout 创建动画，强烈建议使用 requestAnimationFrame。这样会节省很多重复的工作。</p>`,20)])])}const p=s(t,[["render",d]]),m=JSON.parse('{"path":"/code/web/ts/InTheLoop/","title":"深入事件循环（In the Loop）","lang":"zh-CN","frontmatter":{},"git":{"contributors":[{"name":"cy","username":"cy","email":"1058446050@qq.com","commits":2,"url":"https://github.com/cy"}],"changelog":[{"hash":"9b3db7201a77db028445b5bb09d5613d5a8ec5ef","time":1668221777000,"email":"1058446050@qq.com","author":"cy","message":"打包最新"},{"hash":"ad12eb52b2f36055587c281e0aedff3a52822541","time":1668221365000,"email":"1058446050@qq.com","author":"cy","message":"修改目录结构"}]},"filePathRelative":"code/web/ts/InTheLoop/index.md"}');export{p as comp,m as data};
