import{_ as s,c as e,a as n,o as i}from"./app-BZ1Wmvro.js";const d={};function p(r,a){return i(),e("div",null,[...a[0]||(a[0]=[n(`<p>GC（Garbage Collector）就是垃圾收集器，当然这里仅就内存而言。以应用程序的root为基础，遍历应用程序在Heap上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是已经死亡的、哪些仍需要被使用。已经不再被应用程序的root或者别的对象所引用的对象就是已经死亡的对象，即所谓的垃圾，需要被回收。</p><h2 id="什么是内存泄露" tabindex="-1"><a class="header-anchor" href="#什么是内存泄露"><span>什么是内存泄露</span></a></h2><p>任何有经验的 .NET 开发人员都知道，即​​使 .NET 应用程序具有垃圾收集器，内存泄漏也会一直发生。并不是垃圾收集器有错误，只是我们可以很容易在托管语言中导致内存泄漏。随着内存泄漏，您的内存消耗会增加，从而产生 GC 压力和性能问题。最后，程序将因内存不足异常而崩溃。</p><h2 id="发生内存泄露的原因" tabindex="-1"><a class="header-anchor" href="#发生内存泄露的原因"><span>发生内存泄露的原因</span></a></h2><ul><li><p>对象仍被引用但实际上未使用 由于它们被引用，GC 不会收集它们，它们将永远保留，占用内存。例如，当您注册事件但从未取消注册时，可能会发生这种情况。我们称之为托管内存泄漏。</p></li><li><p>以某种方式分配非托管内存（没有垃圾收集）并且不释放它时 .NET 本身有很多分配非托管内存的类。几乎所有涉及流、图形、文件系统或网络调用的事物都在幕后进行。通常，这些类实现一个Dispose方法，释放内存。您可以自己使用特殊的 .NET 类（如Marshal）或PInvoke轻松分配非托管内存。</p></li></ul><h2 id="常见的内存泄露" tabindex="-1"><a class="header-anchor" href="#常见的内存泄露"><span>常见的内存泄露</span></a></h2><h3 id="订阅事件" tabindex="-1"><a class="header-anchor" href="#订阅事件"><span>订阅事件</span></a></h3><p>一旦您订阅了一个事件，该对象就会持有对您的类的引用。除非您使用未捕获类成员的匿名方法订阅。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public class MyClass</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    public MyClass(WiFiManager wiFiManager)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>    private void OnWiFiChanged(object sender, WifiEventArgs e)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        // do something</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>推荐方案</strong> 取消订阅事件。 使用弱处理程序模式。 如果可能，请使用匿名函数订阅并且不捕获任何成员。</p></blockquote><h3 id="以匿名方式捕获成员" tabindex="-1"><a class="header-anchor" href="#以匿名方式捕获成员"><span>以匿名方式捕获成员</span></a></h3><h3 id="静态变量" tabindex="-1"><a class="header-anchor" href="#静态变量"><span>静态变量</span></a></h3><h3 id="缓存功能" tabindex="-1"><a class="header-anchor" href="#缓存功能"><span>缓存功能</span></a></h3><h3 id="不正确的-wpf-绑定" tabindex="-1"><a class="header-anchor" href="#不正确的-wpf-绑定"><span>不正确的 WPF 绑定</span></a></h3><h3 id="永不终止的线程" tabindex="-1"><a class="header-anchor" href="#永不终止的线程"><span>永不终止的线程</span></a></h3><h3 id="不释放非托管内存" tabindex="-1"><a class="header-anchor" href="#不释放非托管内存"><span>不释放非托管内存</span></a></h3><h3 id="添加-dispose-而不调用它" tabindex="-1"><a class="header-anchor" href="#添加-dispose-而不调用它"><span>添加 Dispose 而不调用它</span></a></h3><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><p><a href="https://kb.cnblogs.com/page/106720/" target="_blank" rel="noopener noreferrer">GC垃圾回收原理</a> https://michaelscodingspot.com/ways-to-cause-memory-leaks-in-dotnet/ https://michaelscodingspot.com/find-fix-and-avoid-memory-leaks-in-c-net-8-best-practices/</p>`,19)])])}const c=s(d,[["render",p]]),t=JSON.parse('{"path":"/docs/8c29lgd1/","title":"如何避免内存泄漏","lang":"zh-CN","frontmatter":{"title":"如何避免内存泄漏","createTime":"2026/01/23 11:35:32","permalink":"/docs/8c29lgd1/"},"readingTime":{"minutes":2.15,"words":645},"git":{"createdTime":1769153516000,"updatedTime":1769153516000,"contributors":[{"name":"Z小染","username":"","email":"ryning@sina.com","commits":1,"avatar":"https://gravatar.com/avatar/7097c8ff6482a07ed82070960a9644dc6c0e6b6954b8ae4d6b5bdba65812d1ad?d=retro"}]},"filePathRelative":"docs/DotNet/AvoidMemoryLeak.md","headers":[]}');export{c as comp,t as data};
