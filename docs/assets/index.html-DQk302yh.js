import{_ as s,c as a,a as e,o as t}from"./app-BuzjU66J.js";const p={};function l(o,n){return t(),a("div",null,[...n[0]||(n[0]=[e(`<p>#Thread and Task</p><h2 id="thread" tabindex="-1"><a class="header-anchor" href="#thread"><span>Thread</span></a></h2><p><strong>Thread 默认是前台线程，主线程必须等待前台线程执行完毕后才能退出，thread 可以设置为后台线程，适合长跑型的操作</strong>； 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行；对于比较耗时的操作(例如 io，数据库操作)，或者等待响应(如 WCF 通信)的操作，可以单独开启后台线程来执行，这样主线程就不会阻塞，可以继续往下执行；等到后台线程执行完毕，再通知主线程，然后做出对应操作！</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ThreadTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token class-name">Thread</span> t1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span>DoWork<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化线程</span></span>
<span class="line">  t1<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启线程</span></span>
<span class="line">  t1<span class="token punctuation">.</span><span class="token function">Abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结束线程</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DoWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  …</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意: Thread.Abort 方法是强制停止正在执行的线程，实际并没有真正的停止线程</strong><strong>Abort()方法工作原理</strong>：因为公用语言运行时管理了所有的托管的线程，同样它能在每个线程内抛出异常。Abort 方法能在目标线程中抛出一个 ThreadAbortException 异常从而导致目标线程的终止。不过 Abort 方法被调用后，目标线程可能并不是马上就终止了。因为只要目标线程正在调用非托管的代码而且还没有返回的话，该线程就不会立即终止。而如果目标线程在调用非托管的代码而且陷入了一个死循环的话，该目标线程就根本不会终止。不过这种情况只是一些特例，更多的情况是目标线程在调用托管的代码，一旦 Abort 被调用那么该线程就立即终止了。</p><p>结束线程的最好方法是：在启动的线程中加<strong>信号灯</strong>，当想要终止线程执行时就更改信号灯的状态，启动的线程当读到信号灯状态改变后自己结束代码的执行，这才是最安全的做法。 t1.<strong>Join</strong>();线程阻塞，一直等待线程 t1 终止,才继续向下执行。<strong>信号灯:红灯</strong></p><p><a href="https://www.cnblogs.com/wyy1234/p/9166444.html" target="_blank" rel="noopener noreferrer">Thread 参考链接</a></p><h3 id="threadpool" tabindex="-1"><a class="header-anchor" href="#threadpool"><span>ThreadPool</span></a></h3><p><strong>ThreadPool 默认是后台线程，主线程执行完毕后就能退出，无论后台线程是否执行完毕。ThreadPool 是 Thread 基础上的一个线程池，目的是减少频繁创建销毁线程的开销，适合频繁、短期执行的小操作</strong> 线程池，试想一下，如果有大量的任务需要处理，例如网站后台对于 HTTP 请求的处理，那是不是要对每一个请求创建一个后台线程呢？显然不合适，这会占用大量内存，而且频繁地创建的过程也会严重影响速度，那怎么办呢？线程池就是为了解决这一问题，把创建的线程存起来，形成一个线程池(里面有多个线程)，当要处理任务时，若线程池中有空闲线程(前一个任务执行完成后，线程不会被回收，会被设置为空闲状态)，则直接调用线程池中的线程执行(例 asp.net 处理机制中的 Application 对象)</p><p><strong>缺点：</strong></p><ul><li>ThreadPool 不支持线程的取消、完成、失败通知等交互性操作；</li><li>ThreadPool 不支持线程执行的先后次序； <strong>优点：</strong></li><li>可以避免创建和销毁消除的开支，从而可以实现更好的性能和系统稳定性。</li><li>把线程交给系统进行管理，程序员不需要费力于线程管理，可以集中精力处理应用程序任务。</li></ul><p><a href="https://blog.csdn.net/chen_zw/article/details/7939834?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" target="_blank" rel="noopener noreferrer">线程池详解</a></p><h3 id="线程锁" tabindex="-1"><a class="header-anchor" href="#线程锁"><span>线程锁</span></a></h3><p>在多线程编程中，可能会有许多线程并发的执行一段代码（代码块 A），以提高执行效率。在某些情况下，我们希望 A 中的代码块（B）同步的执行，即同一时刻只有一个线程执行代码块 B，这就需要用到锁（lock）。lock 关键字可以用来确保代码块完成运行，而不会被其他线程中断。它可以把一段代码定义为互斥段（critical section），互斥段在一个时刻内只允许一个线程进入执行，而其他线程必须等待。 线程锁的两种方式：</p><ul><li>Lock：</li></ul><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token class-name">Object</span>  locker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">lock</span><span class="token punctuation">(</span>locker<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">      B    <span class="token comment">//同步执行的代码</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Monitor： Moniter 类提供同步访问对象的机制</li></ul><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token class-name">Object</span>  locker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">Monitor<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span>locker<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//enter(Object)获取排他锁</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">      B</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line">Monitor<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>locker<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//exit(Object)释放指定对象上的排他锁。</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em><strong>locker 必须时引用类型的值。</strong></em></p><p><a href="https://blog.csdn.net/smooth_tailor/article/details/52411359?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" target="_blank" rel="noopener noreferrer">线程锁的学习</a></p><h2 id="task" tabindex="-1"><a class="header-anchor" href="#task"><span>Task</span></a></h2><p>Task 是.NET4.0 加入的，跟线程池 ThreadPool 的功能类似，用 Task 开启新任务时，会从线程池中调用线程，而 Thread 每次实例化都会创建一个新的线程。 开启新任务的方法：Task.Run()或者 Task.Factory.StartNew()，开启的是后台线程要在主线程中等待后台线程执行完毕，可以使用 wait 方法(会以同步的方式来执行)。不用 Wait 则会以异步的方式来执行。 Task 常用方法总结 Task.Run()//异步执行任务方法或 Lambda 表达式 Task.Factory.StartNew(）//异步执行任务方法或 Lambda 表达式,等同于 Task.Run() Task.Delay(numberInMs)//等待等同于睡眠 Thread.Sleep(numberInMs); Task.WhenAny()//任意一个任务完成返回对应任务结果 Task.WhenAll()//所有任务完成 Task.WaitAll(t1,t2,……)；//等待所有任务完成 Task.Wait()；//等待任务完成 Task.ContinueWith(lambda 表达式)//可以让该后台线程继续执行新的任务</p><p><strong>Task.WhenAll()和 Task.WaitAll()区别</strong> WaitAll 就好像是一颗“发霉的花生”，它是<strong>阻塞当前线程</strong>的，当 WaitAll 执行“过去了”的时候还在当前线程继续执行。而<strong>WhenAll 是异步的</strong>，其实异步回调时是使用新的子线程、还是注册 WhenAll 时的线程，是不确定的，核心技术就在于此时根本不占用线程阻塞。这是更重要的区别。</p><ul><li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenall?view=net-5.0" target="_blank" rel="noopener noreferrer">微软 Task 详解</a></li><li><a href="https://www.cnblogs.com/zhaoshujie/p/11082753.html" target="_blank" rel="noopener noreferrer">参考使用链接 1</a></li><li><a href="https://www.cnblogs.com/xiaojidanbai/p/13224172.html" target="_blank" rel="noopener noreferrer">参考使用链接 2</a></li></ul><h2 id="task-于-thread-的区别" tabindex="-1"><a class="header-anchor" href="#task-于-thread-的区别"><span>Task 于 Thread 的区别</span></a></h2><ol><li>任务可以返回结果，没有直接的机制可以从线程返回结果。</li><li>任务通过使用取消令牌来支持取消，但是线程没有。</li><li>一个任务可以同时执行多个线程，线程一次只能运行一个任务。</li><li>可以使用 async 和 await 关键字轻松实现异步。</li><li>新的 Thread 不处理线程池线程，而 Task 确实使用线程池线程。</li><li>任务是比线程更高层次的概念。</li></ol><h3 id="什么是-thread" tabindex="-1"><a class="header-anchor" href="#什么是-thread"><span>什么是 thread</span></a></h3><p>当我们提及多线程的时候会想到 thread 和 threadpool，这都是异步操作，threadpool 其实就是 thread 的集合，具有很多优势，不过在任务多的时候全局队列会存在竞争而消耗资源。thread 默认为前台线程，主程序必须等线程跑完才会关闭，而 threadpool 相反。 总结：threadpool 确实比 thread 性能优，但是两者都没有很好的 api 区控制，如果线程执行无响应就只能等待结束，从而诞生了 task 任务。</p><h3 id="什么是-task" tabindex="-1"><a class="header-anchor" href="#什么是-task"><span>什么是 task</span></a></h3><p>task 简单地看就是任务，那和 thread 有什么区别呢？Task 的背后的实现也是使用了线程池线程，但它的性能优于 ThreadPool,因为它使用的不是线程池的全局队列，而是使用的本地队列，使线程之间的资源竞争减少。同时 Task 提供了丰富的 API 来管理线程、控制。但是相对前面的两种耗内存，Task 依赖于 CPU 对于多核的 CPU 性能远超前两者，单核的 CPU 三者的性能没什么差别</p><p><a href="https://blog.csdn.net/qq_40677590/article/details/102797838" target="_blank" rel="noopener noreferrer">Task 于 Thread 的对比</a></p><h3 id="task-delay-和-thread-sleep-区别" tabindex="-1"><a class="header-anchor" href="#task-delay-和-thread-sleep-区别"><span>Task.Delay()和 Thread.Sleep()区别</span></a></h3><ol><li>Thread.Sleep 是同步延迟，Task.Delay 异步延迟。</li><li>Thread.Sleep 会阻塞线程，Task.Delay 不会。</li><li>Thread.Sleep 不能取消，Task.Delay 可以</li><li>Task.Delay() 比 Thread.Sleep() 消耗更多的资源，但是 Task.Delay()可用于为方法返回 Task 类型；或者根据 CancellationToken 取消标记动态取消等待</li><li>Task.Delay() 实质创建一个运行给定时间的任务， Thread.Sleep() 使当前线程休眠给定时间</li></ol><p><a href="%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://blog.csdn.net/zxf347085420/article/details/93347885?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control">Task.Delay()和 Thread.Sleep()对比</a></p><h3 id="取消阻塞多线程" tabindex="-1"><a class="header-anchor" href="#取消阻塞多线程"><span>取消阻塞多线程</span></a></h3><p><strong>使用 CancellationTokenSource 取消任务</strong></p><p>Task+CancellationTokenSource 共有三种写法：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token class-name">CancellationTokenSource</span> cts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// One</span></span>
<span class="line">taskFactory<span class="token punctuation">.</span><span class="token function">StartNew</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> cts<span class="token punctuation">.</span>Token<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// Two</span></span>
<span class="line"><span class="token class-name">Task</span> task3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> cts<span class="token punctuation">.</span>Token<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// Three</span></span>
<span class="line">Task<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> cts<span class="token punctuation">.</span>Token<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在任务方法体内，通过判断 CancellationTokenSource.IsCancellationRequested 属性，得知线程是否被取消</p><p><strong>ManualResetEvent 线程内部阻塞</strong></p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token comment">//参数值为false线程默认会阻塞</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token class-name">ManualResetEvent</span> mre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ManualResetEvent</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">btnManuResetEvent_Click</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">EventArgs</span> e<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span>Run<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    thread<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>mre<span class="token punctuation">.</span><span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;ThreadId=&quot;</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span>ManagedThreadId <span class="token operator">+</span> <span class="token string">&quot;：&quot;</span> <span class="token operator">+</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">btnStart_Click</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">EventArgs</span> e<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">//放开线程</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>mre<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">btnStop_Click</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">EventArgs</span> e<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">//阻塞线程</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>mre<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><a href="https://blog.csdn.net/xiaouncle/article/details/83037245?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=1328593.10674.16147521124551795&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" target="_blank" rel="noopener noreferrer">取消线程 链接学习目录 8</a></li></ul>`,42)])])}const i=s(p,[["render",l]]),r=JSON.parse('{"path":"/code/dotnet/Multithreading/ThreadAndTask/","title":"","lang":"zh-CN","frontmatter":{},"git":{"contributors":[{"name":"Z小染","username":"","email":"ryning@sina.com","commits":1},{"name":"奶油拌云朵","username":"","email":"ryning@sina.com","commits":2}],"changelog":[{"hash":"7a6707b0a878e0a045555fb731a3c1d7589dacfd","time":1668602449000,"email":"ryning@sina.com","author":"奶油拌云朵","message":"update"},{"hash":"5285ad22209916fb809ed102a8a5958264f17b15","time":1668600192000,"email":"ryning@sina.com","author":"奶油拌云朵","message":"update"},{"hash":"266bf140c565db09c77cb115883b44c423477104","time":1666768997000,"email":"ryning@sina.com","author":"Z小染","message":"add file"}]},"filePathRelative":"code/dotnet/Multithreading/ThreadAndTask/index.md"}');export{i as comp,r as data};
